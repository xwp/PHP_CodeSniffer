#!/usr/bin/env php
<?php
/**
 * Apply PHP_CodeSniffer to changes currently uncommitted to the current repo (currently Git or SVN)
 * or to a diff between two previous commits (revisions). This can be used as a pre-commit hook as well.
 *
 * PHP version 5
 *
 * @category  PHP
 * @package   PHP_CodeSniffer
 * @author    Jack Bates <ms419@freezone.co.uk>
 * @author    Greg Sherwood <gsherwood@squiz.net>
 * @author    Shady Sharaf <shady@x-team.com>
 * @copyright 2006-2013 Squiz Pty Ltd (ABN 77 084 670 600), X-Company Pty Ltd
 * @license   https://github.com/squizlabs/PHP_CodeSniffer/blob/master/licence.txt BSD Licence
 * @link      http://pear.php.net/package/PHP_CodeSniffer
 */

if (is_file(dirname(__FILE__).'/../CodeSniffer/CLI.php') === true) {
    include_once dirname(__FILE__).'/../CodeSniffer/CLI.php';
} else {
    include_once 'PHP/CodeSniffer/CLI.php';
}

define('PHP_CODESNIFFER_SVNLOOK', '/usr/bin/svnlook');

/**
 * Installation instructions for SVN
 * Add the following line to your repofolder/hooks/pre-commit on the svn server
 * /path/to/PHPCS/scripts/phpcs-patch "$1" -t "$2" --standard=WordPress >&2 || exit 1
 *
 * Installation instructions for GIT
 * You can just symlink the file to repofolder/hooks/pre-commit
 * cd /path/to/repofolder/.git/hooks && ln -s /path/to/PHPCS/scripts/phpcs-patch pre-commit
 *
 * Usage of this as a standalone check
 * For SVN:
 * /path/to/phpcs-patch --standard=WordPress /path/to/working/dir -r 21 --local
 * /path/to/phpcs-patch --standard=WordPress /path/to/working/dir -c 21 --local
 *
 * For GIT:
 * /path/to/phpcs-patch --standard=WordPress /path/to/working/dir -r HEAD^
 * /path/to/phpcs-patch --standard=WordPress /path/to/working/dir -r foobar:HEAD^
 */

/**
 * A class to process command line options.
 *
 * @category  PHP
 * @package   PHP_CodeSniffer
 * @author    Jack Bates <ms419@freezone.co.uk>
 * @author    Greg Sherwood <gsherwood@squiz.net>
 * @author    Weston Ruter <weston@x-team.com>
 * @author    Shady Sharaf <shady@x-team.com>
 * @copyright 2006-2012 Squiz Pty Ltd (ABN 77 084 670 600), X-Company Pty Ltd
 * @license   https://github.com/squizlabs/PHP_CodeSniffer/blob/master/licence.txt BSD Licence
 * @version   Release: @package_version@
 * @link      http://pear.php.net/package/PHP_CodeSniffer
 */
class PHP_CodeSniffer_Patch_CLI extends PHP_CodeSniffer_CLI
{

    /**
     * Changes lines in each file, via diff
     * @var array
     */
    public $changed_lines = array();

    /**
     * Repository root, used with git
     * @var array
     */
    public $repo_root = '';

    /**
     * Enable debug messages
     * @var boolean
     */
    public $debug = false;

    /**
     * Get a list of default values for all possible command line arguments.
     *
     * @return array
     */
    public function getDefaults()
    {
        $defaults = parent::getDefaults();

        $defaults['vcsType'] = null;
        $vcs_tests = array(
            'svn' => function () {
                exec( 'svn info 2>&1', $output, $retval );
                return $retval === 0;
            },
            'git' => function () {
                exec( 'git status 2>&1', $output, $retval );
                return $retval === 0;
            },
        );
        foreach ( $vcs_tests as $vcs_type => $vcs_test ) {
            if ( call_user_func( $vcs_test ) ) {
                $defaults['vcsType'] = $vcs_type;
                break;
            }
        }

        $defaults['debug'] = false;
        $defaults['vcsArgs'] = array();
        $defaults['direct-call'] = false; // Defaults to NO, I'M A HOOK

        //$defaults['staged'] = true;
        return $defaults;

    }//end getDefaults()


    /**
     * Processes an unknown command line argument.
     *
     * All unknown args are sent to  commands.
     *
     * @param string $arg    The command line argument.
     * @param int    $pos    The position of the argument on the command line.
     * @param array  $values An array of values determined from CLI args.
     *
     * @return array The updated CLI values.
     * @see getCommandLineValues()
     */
    public function processUnknownArgument($arg, $pos, $values)
    {
        if ( $arg === '--git' ) {
            $values['vcsType'] = 'git';
        }
        else if ( $arg === '--svn' ) {
            $values['vcsType'] = 'svn';
        }
        else if ( $arg == '--debug' ) {
            $values['debug'] = true;
        }
        else if ( $arg == '--local' ) {
            $values['direct-call'] = true;
        }
        else {
            $values['vcsArgs'][] = $arg;
        }
        return $values;

    }//end processUnknownArgument()

    /**
     * Runs PHP_CodeSniffer over files are directories.
     *
     * @param array $values An array of values determined from CLI args.
     *
     * @return int The number of error and warning messages shown.
     * @see getCommandLineValues()
     */
    public function process($values=array())
    {
        if (empty($values) === true) {
            $values = parent::getCommandLineValues();
        }

        $this->debug = $values['debug'];

        $this->repo_root  = trim( `pwd` );

        $paths = array();

        if (empty($values['vcsType'])) {
            printf( 'Unknown VCS' . PHP_EOL );
            exit(1);
        }

        // Extract rev from arguments
        $vcs_rev = null;
        if ( false !== ( $rev_key = array_search( '-r', $values['vcsArgs'] ) ) ) {
            $vcs_rev = $values['vcsArgs'][$rev_key + 1];
            unset($values['vcsArgs'][$rev_key]);
            unset($values['vcsArgs'][$rev_key + 1]);
        }

        // 1. Get changed files
        // This should get staged files if used a pre-commit,
        // or changes between a revision (-r xx) and HEAD,
        // or changes between a revision range (-r xx:yy )
        // --------------------
        
        if ($values['vcsType'] === 'git') {
            $rev = ( $vcs_rev === null ) ? '--staged' : str_replace( ':', ' ', $vcs_rev );
            $command = sprintf(
                'git diff --name-status %s',
                $rev
                );
        }
        else if ($values['vcsType'] === 'svn') {
            // If supplied a transaction, or running on server, use svnlook, to handle svn:pre-commit ( on svn server )
            if ( in_array( '-t', $values['vcsArgs'] ) || ! $values['direct-call'] ) {
                $command = sprintf(
                    'svnlook changed %s',
                    implode(' ', $values['vcsArgs'])
                );
            }
            // else, use svn diff, to handle local execution
            else {
                $args = array_splice( $values['vcsArgs'], 1 );
                if ( $vcs_rev ) {
                    $rev = $vcs_rev;
                    if ( strpos( $rev, ':' ) === false ) {
                        $rev = $vcs_rev . ':HEAD';
                    }
                }
                else {
                    $info = preg_match('#Revision: (\d+)#', `svn info -r 'HEAD' | grep 'Revision: '`, $matches ) ? $matches[1] : null;
                    $rev = ( intval( $info ) - 1 ) . ':' . 'HEAD';
                }
                $command = sprintf(
                    'svn diff -r %s %s --summarize',
                    $rev,
                    implode( ' ', $args )
                    );
                
            }
        }
        else {
            printf( 'Unknown VCS of type "%s".' . PHP_EOL, $values['vcsType'] );
            exit(1);
        }
        $contents = $this->executeCommand( $command );

        // Filter changed files, add to paths to check
        foreach( preg_split("/\v|\n/", $contents, -1, PREG_SPLIT_NO_EMPTY) as $line ) {
            // Skip deleted lines
            if ( preg_match( '/^D.*/', $line ) ) {
                continue;
            }
            // Drop the four characters representing the action which precede the path on each line.
            if ( $values['vcsType'] == 'git' ) {
                $pattern = '/^\S+\s+/';
            }
            elseif ( $values['vcsType'] == 'svn' ) {
                $pattern = '/^.{4}/';
            }
            $paths[] = trim( 
                preg_replace( 
                    $pattern, 
                    '', 
                    str_replace(
                        $this->repo_root.'/', 
                        '', 
                        $line)
                    )
                );
        }

        $values['standard'] = $this->validateStandard($values['standard']);
        if (PHP_CodeSniffer::isInstalledStandard($values['standard']) === false) {
            // They didn't select a valid coding standard, so help them
            // out by letting them know which standards are installed.
            printf( 'ERROR: the "%s" coding standard is not installed.' . PHP_EOL, $values['standard'] );
            $this->printInstalledStandards();
            exit(2);
        }
 
        $phpcs = new PHP_CodeSniffer(
            $values['verbosity'],
            $values['tabWidth'],
            $values['encoding']
        );

        // Set file extensions if they were specified. Otherwise,
        // let PHP_CodeSniffer decide on the defaults.
        if (empty($values['extensions']) === false) {
            $phpcs->setAllowedFileExtensions($values['extensions']);
        }

        // Set ignore patterns if they were specified.
        if (empty($values['ignored']) === false) {
            $phpcs->setIgnorePatterns($values['ignored']);
        }

        // Set some convenience member vars.
        if ($values['errorSeverity'] === null) {
            $this->errorSeverity = PHPCS_DEFAULT_ERROR_SEV;
        } else {
            $this->errorSeverity = $values['errorSeverity'];
        }

        if ($values['warningSeverity'] === null) {
            $this->warningSeverity = PHPCS_DEFAULT_WARN_SEV;
        } else {
            $this->warningSeverity = $values['warningSeverity'];
        }

        // Initialize PHP_CodeSniffer listeners but don't process any files.
        $phpcs->setCli($this);
        $phpcs->process(array(), $values['standard'], $values['sniffs']);

        // 2. Get content of each changed file
        // -----------------------------------
        
        foreach ($paths as $path) {
            // No need to process folders as each changed file is checked.
            if (substr($path, -1) === '/') {
                continue;
            }

            // We need to check ignore rules ourselves because they are
            // not checked when processing a single file.
            if ($phpcs->shouldProcessFile($path, dirname($path)) === false) {
                continue;
            }


            if ( $values['vcsType'] == 'git' ) {
                // Get file from a certain revision, fallback to STAGED if not provided
                $rev = ( $vcs_rev )
                    ? $rev = str_replace( ':', ' ', $vcs_rev )
                    : '';
                $command = sprintf( 
                    'git show %s:%s',
                    $rev, // Empty rev means staged file
                    $path
                    );
            }
            elseif ( $values['vcsType'] == 'svn' ) {
                // Transactions happen on svn server, not local 
                if ( ! $values['direct-call'] ) {
                    // Get the contents of each file, as it would be after this transaction.
                    $command = sprintf(
                        PHP_CODESNIFFER_SVNLOOK . ' cat %s %s',
                        implode(' ', $values['vcsArgs']),
                        $path
                        );
                }
                else { // locally invoked
                    // We're cd'ing to the dir anyway, no need to pass the directory
                    $args = array_splice( $values['vcsArgs'], 1 );

                    // We need the file at that certain revision, -c here doesn't fit, replace with -r
                    if ( false !== ( $_c = array_search( '-c', $args ) ) ) {
                        unset($args[$_c]);
                        $vcs_rev = $args[$_c + 1];
                        unset($args[$_c + 1]);
                    }

                    if ( $vcs_rev ) {
                        $rev = $vcs_rev;
                        if ( strpos( $rev, ':' ) !== false ) {
                            $rev = preg_match( '#(.*):#', $rev, $matches ) ? $matches[1] : null;
                        }
                    }
                    else {
                        $info = preg_match('#Revision: (\d+)#', `svn info -r 'HEAD' | grep 'Revision: '`, $matches ) ? $matches[1] : null;
                        $rev = ( intval( $info ) - 1 );
                    }

                    $command = sprintf(
                        'svn cat -r %s %s %s',
                        implode( ' ', $args ),
                        $rev,
                        str_replace($this->repo_root.'/', '', $path)
                        );
                }
            }
            
            $contents = $this->executeCommand( $command );

            $phpcs->processFile( $path, $contents );

        }//end foreach

        return $this->printErrorReport(
            $phpcs,
            $values['reports'],
            $values['showSources'],
            $values['reportFile'],
            $values['reportWidth']
        );

    }//end process()

    /**
     * Process VCS diff, and extract changes lines
     * @return array changed lines
     */
    public function process_diff() {

        $values = parent::getCommandLineValues();
        $vcs = $values['vcsType'];

        if ( $vcs == 'git' ) {
            $args = $values['vcsArgs'];
            // Check staged files if no revision is passed
            $rev = '--staged';
            if ( false !== ( $_r = array_search( '-r', $args ) ) ) {
                $rev = $args[$_r+1];
                if ( false !== strpos( $rev, ':' ) ) {
                    $rev = str_replace(':', ' ', $rev);
                }
                $rev = $rev . ' --';
            }
            $command = sprintf(
                'git diff -U0 %s',
                $rev
                );
        }
        elseif ( $vcs == 'svn' ) {
            $args = array_splice( $values['vcsArgs'], 1 );
            // remove transaction info from args, svn diff doesn't like it, and it is not needed anyway
            if ( false !== ( $_t = array_search( '-t', $args ) ) ) {
                unset($args[$_t]);
                unset($args[$_t+1]);
            }
            $command = sprintf( 
                'svn diff %s --no-diff-deleted --diff-cmd diff -x -U0', 
                implode( ' ', $args )
                );
        }

        $diffs = $this->executeCommand( $command, true );

        $files = array();
        $file  = '';

        $scope = 0;
        $scope_start = 0;
        foreach ( $diffs as $i => $line ) {
            if ( $vcs == 'git' && preg_match( '#diff --git a/(\S+)#', $line, $matches ) ) {
                $file = $matches[1];
                $files[$file] = array();
            }
            if ( $vcs == 'svn' && preg_match( '#^\+\+\+ (\S+)#', $line, $matches ) ) {
                $file = str_replace( $this->repo_root . '/', '', $matches[1] );
                $files[$file] = array();
            }
            elseif ( preg_match( '#^@@#', $line ) ) {
                $scope = $i;
                $scope_start = preg_match( '#^@@.*\+(\d+)#', $line, $matches ) ? $matches[1] : null;
                continue;
            }
            elseif ( preg_match( '#^\+[^\+]#', $line ) ) {
                $files[$file][] = $scope_start + ( $i - $scope - 1 );
                $scope_start += 1;
                continue;
            }
            elseif ( preg_match( '#\ No newline at end of file"#', $line ) ) {
                continue;
            }
            $scope_start -= 1;
        }

        return $files;

    }


    /**
     * Prints out the usage information for this script.
     *
     * @return void
     */
    public function printUsage()
    {
        parent::printUsage();

        // svn look:
        // -r [--revision] ARG      : specify revision number ARG
        // -t [--transaction] ARG   : specify transaction name ARG
//        Transaction ID only makes sense for transactions that are not yet
//        committed, i.e. during commit - when files are already on the server
//        side, but not in repository yet.
//
//            So, this transaction ID only valid when pre-commit hook is called, after
//        commit is completed transaction is deleted and instead new revision in
//        repository appears.

        echo PHP_EOL;
        echo '    Each additional argument is passed to the current repo\'s VCS tool'.PHP_EOL;
        echo '    The report is printed on standard output,'.PHP_EOL;
        echo '    however Subversion displays only standard error to the user, so in a'.PHP_EOL;
        echo '    pre-commit hook, this script should be invoked as follows:'.PHP_EOL;
        echo PHP_EOL;
        echo '    '.basename($_SERVER['argv'][0]).' ... "$REPOS" -t "$TXN" >&2 || exit 1'.PHP_EOL;

    }//end printUsage()

    /**
     * Prints the error report for the run.
     *
     * Note that this function may actually print multiple reports
     * as the user may have specified a number of output formats.
     *
     * @param PHP_CodeSniffer $phpcs       The PHP_CodeSniffer object containing
     *                                     the errors.
     * @param array           $reports     A list of reports to print.
     * @param bool            $showSources TRUE if report should show error sources
     *                                     (not used by all reports).
     * @param string          $reportFile  A default file to log report output to.
     * @param int             $reportWidth How wide the screen reports should be.
     *
     * @return int The number of error and warning messages shown.
     */
    public function printErrorReport(
        PHP_CodeSniffer $phpcs,
        $reports,
        $showSources,
        $reportFile,
        $reportWidth
    ) {
        $reporting       = new PHP_CodeSniffer_Reporting();
        $filesViolations = $phpcs->getFilesErrors();

        $changed_lines = $this->process_diff();
        foreach ( $filesViolations as $file => $issues ) {
            if ( empty( $changed_lines[$file] ) ) {
                $this->debug && printf( 'File %s didnt change in specified range.', $file );
            }
            else {
                foreach ( array( 'warnings', 'errors' ) as $type ) {
                    $count = 0;
                    foreach ( $issues[$type] as $line => $issue ) {
                        if ( ! in_array( $line, $changed_lines[$file] ) ) {
                            unset( $filesViolations[$file][$type][$line] );
                        } else {
                            $count += count($issue);
                        }
                    }
                    $filesViolations[$file]['num' . ucfirst($type)] = $count;
                    $count = 0;
                }
            }
        }

        if (empty($reports) === true) {
            $reports['full'] = $reportFile;
        }

        $errors   = 0;
        $toScreen = false;

        foreach ($reports as $report => $output) {
            if ($output === null) {
                $output = $reportFile;
            }

            if ($reportFile === null) {
                $toScreen = true;
            }

            // We don't add errors here because the number of
            // errors reported by each report type will always be the
            // same, so we really just need 1 number.
            $errors = $reporting->printReport(
                $report,
                $filesViolations,
                $showSources,
                $output,
                $reportWidth
            );
        }

        // Only print PHP_Timer output if no reports were
        // printed to the screen so we don't put additional output
        // in something like an XML report. If we are printing to screen,
        // the report types would have already worked out who should
        // print the timer info.
        if ($toScreen === false
            && PHP_CODESNIFFER_INTERACTIVE === false
            && class_exists('PHP_Timer', false) === true
        ) {
            echo PHP_Timer::resourceUsage().PHP_EOL.PHP_EOL;
        }

        // They should all return the same value, so it
        // doesn't matter which return value we end up using.
        return $errors;

    }//end printErrorReport()

    function executeCommand( $command, $split = false ) {
        $handle = popen( sprintf(
                            'cd %s && %s',
                            $this->repo_root,
                            $command
                            ),
                        'r' );
        if ($handle === false) {
            printf( 'Could not execute: %s' . PHP_EOL, $command );
            exit(1);
        }
        $contents = stream_get_contents($handle);
        fclose($handle);
        if ( $split ) {
            $lines = preg_split("/\v|\n/", $contents, -1, PREG_SPLIT_NO_EMPTY);
            $contents = $lines;
        }

        $this->debug && printf( '== Executing: %s' . PHP_EOL, $command );
        return $contents;
    }


}//end class

$phpcs = new PHP_CodeSniffer_Patch_CLI();
$phpcs->checkRequirements();

$numErrors = $phpcs->process();
if ($numErrors !== 0) {
    exit(1);
}

?>
